# -*- coding: utf-8 -*-
"""bert_mlp_scoring.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/158QguAeoFwXQdJA5dcAyBI7qbgjYL8on
"""

import pandas as pd

from google.colab import drive
drive.mount('/content/drive')

sentiment_df = pd.read_csv("/content/drive/MyDrive/Ehwa/new_predictions.csv")

sentiment_df.head()

sentiment_map = {"부정": 0, "중립": 0.5, "긍정": 1}

for col in ["price_pred", "service_pred", "taste_pred", "ambience_pred"]:
    sentiment_df[f"{col}_score"] = sentiment_df[col].map(sentiment_map)

store_score_df = sentiment_df.groupby(["id","name"]).agg(
    price_mean=("price_pred_score", "mean"),
    service_mean=("service_pred_score", "mean"),
    taste_mean=("taste_pred_score", "mean"),
    ambience_mean=("ambience_pred_score", "mean"),
    review_count=("review_no", "count")
).reset_index()

store_score_df.head()

def bayesian_avg(r, v, c, m=30):
    return (v / (v + m)) * r + (m / (v + m)) * c


c_price = store_score_df["price_mean"].mean()
c_service = store_score_df["service_mean"].mean()
c_taste = store_score_df["taste_mean"].mean()
c_ambience = store_score_df["ambience_mean"].mean()


store_score_df["price_bayes"] = store_score_df.apply(lambda x: bayesian_avg(x["price_mean"], x["review_count"], c_price, m=30), axis=1)
store_score_df["service_bayes"] = store_score_df.apply(lambda x: bayesian_avg(x["service_mean"], x["review_count"], c_service, m=30), axis=1)
store_score_df["taste_bayes"] = store_score_df.apply(lambda x: bayesian_avg(x["taste_mean"], x["review_count"], c_taste, m=30), axis=1)
store_score_df["ambience_bayes"] = store_score_df.apply(lambda x: bayesian_avg(x["ambience_mean"], x["review_count"], c_ambience, m=30), axis=1)

store_score_df.head()

store_score_df.to_csv("restaurant_bayes_scores.csv", index=False, encoding="utf-8-sig")

result_df = sentiment_df.merge(
    store_score_df[["id", "name", "taste_bayes", "service_bayes", "price_bayes", "ambience_bayes"]],
    on="id",
    how="left"
)

result_df.head()

result_df = result_df.drop(['price_pred_score', 'service_pred_score', 'taste_pred_score','ambience_pred_score','name_y'], axis=1)

result_df.head()

id_df = pd.read_csv('/content/drive/MyDrive/Ehwa/캡스톤/1.id_v2.csv')
id_df.head()

result_df = result_df.merge(
    id_df[["id", "category_1", "category_2"]],
    on="id",
    how="left"
)

result_df.head()

# result_df = result_df.drop('name_x', axis=1)

exit_df = pd.read_csv('/content/drive/MyDrive/Ehwa/캡스톤/2.opentime_v2.csv')

exit_df.head()

import re

def is_open_in_range(time_str, start, end):
    """[HH:MM~HH:MM] 문자열이 특정 시간대(start~end)와 겹치는지 판별"""
    if pd.isna(time_str):
        return False

    match = re.findall(r'(\d{1,2}):(\d{2})', time_str)
    if len(match) != 2:
        return False

    open_time = int(match[0][0]) + int(match[0][1]) / 60
    close_time = int(match[1][0]) + int(match[1][1]) / 60
    start_time = int(start.split(':')[0]) + int(start.split(':')[1]) / 60
    end_time = int(end.split(':')[0]) + int(end.split(':')[1]) / 60

    return not (close_time < start_time or open_time > end_time)


# ".open"이 들어간 모든 요일 컬럼 탐색
open_cols = [col for col in exit_df.columns if ".open" in col]

# 각 요일별 점심 / 저녁 여부 계산
for col in open_cols:
    day = col.split(".")[0]  # 예: "Mon.open" → "Mon"
    exit_df[f"{day}_lunch"] = exit_df[col].apply(lambda x: is_open_in_range(x, "11:00", "14:00"))
    exit_df[f"{day}_dinner"] = exit_df[col].apply(lambda x: is_open_in_range(x, "17:00", "20:00"))

# 결과 확인
exit_df[[col for col in exit_df.columns if "lunch" in col or "dinner" in col]].head()

exit_df.head()

result_df = result_df.merge(
    exit_df[["id", "station",  "Mon_lunch",	"Mon_dinner",	"Tue_lunch",	"Tue_dinner",	"Wed_lunch",	"Wed_dinner",	"Thu_lunch",	"Thu_dinner",	"Fri_lunch",	"Fri_dinner",	"Sat_lunch",	"Sat_dinner",	"Sun_lunch",	"Sun_dinner"]],
    on="id",
    how="left"
)
result_df.head()

result_df.to_csv('/content/drive/MyDrive/Ehwa/vectorDb_final.csv', index=False, encoding='utf-8-sig')

